// TS3Client - A free TeamSpeak3 client implementation
// Copyright (C) 2017  TS3Client contributors
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the Open Software License v. 3.0
//
// You should have received a copy of the Open Software License along with this
// program. If not, see <https://opensource.org/licenses/OSL-3.0>.

<#@ template debug="true" hostSpecific="true" language="C#" #>
<#@ include file="MessageParser.ttinclude" once="true" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#= "// *** DO NOT EDIT THIS FILE, IT HAS BEEN AUTO-GENERATED ***" #>

namespace TS3Client.Messages
{
	using Commands;
	using Helper;
	using System;
	using System.Globalization;

	using UidT = System.String;
	using ClientDbIdT = System.UInt64;
	using ClientIdT = System.UInt16;
	using ChannelIdT = System.UInt64;
	using ServerGroupIdT = System.UInt64;
	using ChannelGroupIdT = System.UInt64;

<#
var gen = ParseMessages();

string GenerateDeserializer(GenField fld)
{
	if(fld.isArray)
		return $"{{ if(value.Length == 0) {fld.fldName} = Array.Empty<{fld.fldType}>(); else {{"
			    + $" var ss = new SpanSplitter(); ss.First(value, ',');"
			    + $" int cnt = 0; for (int i = 0; i < value.Length; i++) if (value[i] == ',') cnt++;"
			    + $" {fld.fldName} = new {fld.fldType}[cnt + 1];"
			    + $" for(int i = 0; i < cnt + 1; i++) {{ {GenerateSingleDeserializer(fld, "ss.Trim(value)", fld.fldName + "[i]")} if (i < cnt) value = ss.Next(value); }} }} }}";
	else
		return GenerateSingleDeserializer(fld, "value", fld.fldName);
}

string GenerateSingleDeserializer(GenField fld, string input, string output)
{
	GenType typeInfo;
	if(!gen.Types.TryGetValue(fld.fldType, out typeInfo))
		throw new Exception("Unregistered type");
	switch (fld.fldType)
	{
	case "bool":
		return $"{output} = {input}.Length > 0 && {input}[0] != '0';";
	case "sbyte":
	case "byte":
	case "short":
	case "ushort":
	case "int":
	case "uint":
	case "long":
	case "ulong":
	case "float":
	case "double":
	case "ClientDbIdT":
	case "ClientIdT":
	case "ChannelIdT":
	case "ServerGroupIdT":
	case "ChannelGroupIdT":
		return $"{output} = {fld.fldType}.Parse({input}.NewString(), CultureInfo.InvariantCulture);";
	case "TimeSpanSecondsT":
		return $"{output} = TimeSpan.FromSeconds(double.Parse({input}.NewString(), CultureInfo.InvariantCulture));";
	case "TimeSpanMillisecT":
		return $"{output} = TimeSpan.FromMilliseconds(double.Parse({input}.NewString(), CultureInfo.InvariantCulture));";
	case "DateTime":
		return $"{output} = Util.UnixTimeStart.AddSeconds(double.Parse({input}.NewString(), CultureInfo.InvariantCulture));";
	case "string":
	case "UidT":
		return $"{output} = Ts3String.Unescape({input});";
	case "HostMessageMode":
	case "CodecEncryptionMode":
	case "HostBannerMode":
	case "Reason":
	case "ClientType":
	case "TextMessageTargetMode":
	case "GroupType":
	case "GroupNamingMode":
		return $"{{ if (!Enum.TryParse({input}.NewString(), out {fld.fldType} val)) throw new FormatException(); {output} = val; }}";
	case "Codec":
	case "Ts3ErrorCode":
	case "LicenseType":
	case "PermissionId":
		return $"{output} = ({fld.fldType}){typeInfo.backingType}.Parse({input}.NewString(), CultureInfo.InvariantCulture);";
	case "IconHash":
		return $"{output} = unchecked((int)long.Parse({input}.NewString(), CultureInfo.InvariantCulture));";
	default:
		return "#error missing deserializer";
	}
}

string GenerateType(GenField fld)
{
	string final;
	switch (fld.fldType)
	{
	case "TimeSpanSecondsT": final = "TimeSpan"; break;
	case "TimeSpanMillisecT": final = "TimeSpan"; break;
	case "IconHash": final = "int"; break;
	default: final = fld.fldType; break;
	}

	return final + (fld.isArray ? "[]" : "");
}

foreach(var msg in gen.MessagesSorted)
{
	if(!msg.S2C) continue;
#>
	public sealed class <#= msg.ClassName #><#
		bool isNotify = msg.Notify != null;
		bool isResponse = msg.Response;
		if (isNotify && isResponse) Write(" : INotification, IResponse");
		else if (isNotify) Write(" : INotification");
		else if (isResponse) Write(" : IResponse");
	#>
	{
		<#= isNotify ? "public NotificationType NotifyType { get; } = NotificationType." + msg.ClassName + ";" : "" #>
		<#= isResponse ? "public string ReturnCode { get; set; }" : "" #>
<#
	foreach (var genField in msg.Fields.Values) { #>
		public <#= genField.Field.genType #> <#= genField.Field.fldName #> { get; set; }<# } #>

		public void SetField(string name, ReadOnlySpan<char> value)
		{
<#
		if (msg.Fields.Values.Count > 0) { #>
			switch(name)
			{
<#
		foreach (var genField in msg.Fields.Values) {
#>
			case "<#= genField.Field.tsName #>": <#= GenerateDeserializer(genField.Field) #> break;<#
			}
#>
			<#= isResponse ? ("case \"return_code\": " + GenerateDeserializer(gen.Fields["return_code"]) + " break;") : "" #>
			}
<#
			} #>
		}
	}
<# } #>
	public enum NotificationType
	{
		Unknown,<#
	foreach(var ntfy in gen.NotifiesSorted) {
		if(!gen.Messages[ntfy.ClassName].S2C) continue; #>
		<#= ntfy.ClassName #>,<#
	}
#>
	}

	public static class MessageHelper
	{
		public static NotificationType GetNotificationType(string name)
		{
			switch(name)
			{<#
	foreach(var ntfy in gen.NotifiesSorted) { 
		if(!gen.Messages[ntfy.ClassName].S2C) continue; #>
			case "<#= ntfy.Notify #>": return NotificationType.<#= ntfy.ClassName #>;<#
	}
#>
			default: return NotificationType.Unknown;
			}
		}

		public static INotification GenerateNotificationType(NotificationType name)
		{
			switch(name)
			{<#
	foreach(var ntfy in gen.NotifiesSorted)
	{
		if(!gen.Messages[ntfy.ClassName].S2C) continue;
#>
			case NotificationType.<#= ntfy.ClassName #>: return new <#= ntfy.ClassName #>();<#
	}
#>
			case NotificationType.Unknown:
			default: throw Util.UnhandledDefault(name);
			}
		}
	}
}